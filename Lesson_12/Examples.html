Розв_язані_задачі.html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<script>
			// Тестовий масив
			// let arr = [
			//   56, -78, 252, 23, -122, 356, 122, 436,
			//   -111, 344, 21, 3, -356, 342,
			// ]
			//----- Сортування вибором 1.
			// const prevLastIndex = arr.length - 2
			// let counter = 0
			// for (let i = 0; i <= prevLastIndex; i++) {
			//   for (let j = i + 1; j < arr.length; j++) {
			//     if (arr[i] < arr[j]) {
			//       let temp = arr[i]
			//       arr[i] = arr[j]
			//       arr[j] = temp
			//       counter++
			//     }
			//   }
			// }
			// document.write(arr)
			// console.log(counter)
			//----- Сортування вибором 2
			// const prevLastIndex = arr.length - 2
			// let counter = 0
			// for (let i = 0; i <= prevLastIndex; i++) {
			//   let minIndex = i
			//   //----- пошук індекса мінімального елемента від і-до останнього
			//   for (let j = i + 1; j < arr.length; j++) {
			//     if (arr[j] < arr[minIndex]) {
			//       minIndex = j
			//     }
			//   }
			//   //---- якщо мінімлаьний не у позиції "і" то міняємо місцями
			//   if (i !== minIndex) {
			//     let temp = arr[i]
			//     arr[i] = arr[minIndex]
			//     arr[minIndex] = temp
			//     counter++
			//   }
			// }
			// document.write(arr)
			// console.log(counter)

			//------------Quick ---
			// //Функція обміну елементів місцями
			// function swap(A, i, j) {
			//   let temp = A[i]
			//   A[i] = A[j]
			//   A[j] = temp
			// }

			// //Поділ фрагменту від p до q
			// //на дві частини (<=pivot та >pivot)
			// function Partition(A, p, q) {
			//   let pivot = A[q]
			//   let i = p - 1
			//   for (let j = p; j < q; j++) {
			//     if (A[j] <= pivot) {
			//       i = i + 1
			//       swap(A, i, j)
			//     }
			//   }
			//   swap(A, i + 1, q)
			//   //повертаємо нову позицію pivot
			//   return i + 1
			// }

			// //Основна функція
			// function Quicksort(A, p, q) {
			//   if (p >= q) return
			//   //ділимо на дві частини
			//   let i = Partition(A, p, q)
			//   //окремо сортуємо першу частину
			//   Quicksort(A, p, i - 1)
			//   //окремо сортуємо другу частину
			//   Quicksort(A, i + 1, q)
			// }

			// Quicksort(arr, 0, arr.length - 1)
			// document.write(arr)

			//=============== Задачі з одновимірними масивами ============================================
			// let arr = [
			//   56, -78, 252, 23, -122, 356, 122, 436, -111, 344, 21, 3, -356, 342,
			// ]
			//=========================================================================================
			//Список тих цін, які більші за попереднє значення

			// alert(resArr)
			//=========================================================================================
			//=========================================================================================
			//=========================================================================================
			//=========================================================================================
			//=========================================================================================
			//=========================================================================================
			let scores = [56, -78, 252, 23, -122, 356, 0, 122, 436, -111, 0, 344, 21, 3, -356, 342];
			//=========================================================================================
			//Задача. Дано випадкові значення виграшів - результати ігрового барабана (від -500 до 500)
			// //  15) Упорядквати за зростанням
			// scores.sort((a, b) => a - b)
			// //  16) Упорядквати за спаданням
			// scores.sort((a,b)=>b-a)

			// //  17) Упорядкувати так, щоб спочатку були від"ємні (без зміни їх слідування), потім всі інші(без зміни їх слідування)
			// scores.sort((a, b) => {
			//   if (a < 0 && b >= 0) return -1
			//   if (a >= 0 && b < 0) return 1
			//   return 0
			// })

			// document.write(`${scores}<br><br>`)
			// console.log(scores)
			// let scores = [
			//   56, -78, 252, 23, -122, 356, 0, 122, 436, -111, 0, 344, 21, 3, -356,
			//   342,
			// ]
			//  18) Упорядкувати так, щоб спочатку були нулі, потім від"ємні, потім додатні
			// scores.sort((a, b) => {
			//   if (a === 0 && b !== 0) return -1
			//   if (a !== 0 && b === 0) return 1
			//   return a - b
			// })
			// document.write(`${scores}<br><br>`)

			//Задача. Запрограмувати пошук бінарним методом
			//       0   1  2  3   4   5   6  7  <- індекси (length = 8) (номер останнього = (length-1)
			let a = [23, 0, 0, 4, 11, -2, 9, -5];

			//---- Сортування включеннями
			//---- Перевірка належності елемента упорядкованого масиву
			//     (належить - true, не належить - false)
			// function includes_binarySearch(arr, searchElement) {

			// }

			//---- Знаходження інексу елемента у масиві (якщо немає, то результат = -1)
			// function findIndex_binarySearch(arr, searchElement) {

			// }

			//========================================================================
			//Задача. Дано масив імен користувачів
			let names = ["John", "Paul", "Olga", "Andrew", "Abrams", "Abba", "Peter", "Tina", "Olga", "Jack", "Peter"];
			// 1) Упорядкувати масив за зростанням
			// names.sort()

			// 2) Упорядкувати масив за спаданням
			//---- 1 ---  sort().reverse()
			// names.sort().reverse()
			//---- 2 ---
			// names.sort((a, b) => {
			//   if (a < b) return 1
			//   if (a > b) return -1
			//   return 0
			// })

			// 3) Упорядкувати масив за першою літерою за зростанням
			// names.sort((a, b) => {
			//   const code1 = a.charCodeAt(0)
			//   const code2 = b.charCodeAt(0)
			//   return code1 - code2
			// })
			// 3) Упорядкувати масив за першою літерою за спаданням
			// names.sort((a, b) => {
			//   const code1 = a.charCodeAt(0)
			//   const code2 = b.charCodeAt(0)
			//   return code1 - code2
			// })
			// 4) Упорядкувати масив за другою літерою за спаданням
			// 5) Упорядкувати масив за зростанням довжин імен
			// 6) Упорядкувати масив за спаданням довжин імен
			// 7) Упорядкувати масив так, щоб спочатку були Peter, потім всі інші
			// 8) Упорядкувати масив так, щоб спочатку були Peter, в кінці Olga потім всі інші

			// document.write(names)
			//========================================================================
			//   2)Сформувати новий масив, у якому є номери тільки тих, що більші за 1000 грн.
			//========================================================================
			// Морський бій. Випадковим чином на двовимірному полі розміром 6*6 розташовується 5 кораблів. Користувач стріляє вказуючи координати. Гра продовжується поки не потоплено усі кораблі або у користувача не закінчаться снаряди.
			// function generateGameField(rowsNumber, colsNumber, shipsNumber) {
			//   //---- Створюємо масив заповнений нулями
			//   let arr =[]
			//   for (let row = 0; row < rowsNumber; row++) {
			//     let newRow = new Array(colsNumber).fill(0)
			//   }
			//   //---- Розміщуємо кораблі
			//   for (let shipNum = 0; shipNum < shipsNumber; ) {
			//     const randRowIndex = Math.floor(Math.random()*rowsNumber)
			//     const randColIndex = Math.floor(Math.random()*colsNumber)
			//     if(arr[randRowIndex] [randColIndex] !==1){
			//       arr[randRowIndex] [randColIndex] =1
			//       shipNum++
			//     }
			//   }
			//   return arr
			// }
			//========================================================================
			// let arr = [
			//   [1, 3, 0, 8, 2],
			//   [1, 0, 0, 18, 2],
			//   [0, 3, 0, 1, 0],
			// ]
			// Знайти загальну кількість нулів у двовимірному масиві
			//------- 1
			// let zeroNum = arr
			//   .flat()
			//   .reduce(
			//     (prevZeroNum, el) => (el === 0 ? prevZeroNum + 1 : prevZeroNum),
			//     0
			//   )

			//------- 2
			// let zeroNum = arr.reduce((prevTotalZeroSum, row) => {
			//   //---- знаходження кількості нулів у поточному рядку row
			//   let zerowsInRow = row.reduce(
			//     (prevZeroInRow, el) => (el === 0 ? prevZeroInRow + 1 : prevZeroInRow),
			//     0
			//   )
			//   //---- до загальної кількості нулів додаємо кількість нулів у поточному рядку
			//   return prevTotalZeroSum + zerowsInRow
			// }, 0)
			// document.write(zeroNum)
			//========================================================================
			// Знайти максимальну кількість нулів у одному рядку
			// let maxZeroInOneRow = arr.reduce((prevMaxZeroNum, row) => {
			//   //--- знаходимо кількість нулів у рядку row
			//   let zeroNumInRow = row.reduce(
			//     (prevZeroNum, el) => (el === 0 ? prevZeroNum + 1 : prevZeroNum),
			//     0
			//   )
			//   //--- порівнюємо з попереднім максимальним значенням
			//   return zeroNumInRow > prevMaxZeroNum ? zeroNumInRow : prevMaxZeroNum
			// }, -Infinity)

			// document.write(maxZeroInOneRow)

			//========================================================================
			//відсортувати тижні (рядки) за спаданням максимального елементи у цьому тижні (рядку), тобто при порівнянні рядків потрібно порівнювати максимальні елементи у кожному з цих рядків
			// 1) потрібно створити масив з максимальних елементів рядків  maxRowsElements
			// 2) упорядковувати масив maxRowsElements (і якщо міняємо якісь елементи у масиві maxRowsElements, то
			// треба міняти місцями і відповідні рядки)

			//========================================================================
			//========================================================================
		</script>
	</body>
</html>
